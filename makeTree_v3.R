#' Make Tree of Possible Question Combinations
#'
#' Pre-calculates a complete branching scheme of all possible questions-answer combinations and stores it as a list of lists or a flattened table of values.
#'
#' @param catObj An object of class \code{Cat}
#' @param flat A logical indicating whether to return tree as as a list of lists or a table
#'
#'
#' @details The function takes a \code{Cat} object and generates a tree of all possible question-answer combinations, conditional on previous answers in the branching scheme and the current \eqn{\theta} estimates for the branch.
#' The tree is stored as a list of lists, iteratively generated by filling in a possible answer, calculating the next question via \code{selectItem}, filling in a possible answer for that question, and so forth.
#' 
#' The length of each complete branching scheme within the tree is dictated by the \code{lengthThreshold} slot within the \code{Cat} object.
#' 
#' @return The function \code{makeTree} returns either a list or a table.  If the argument \code{flat} is \code{FALSE}, the default value, the function returns a list of lists.
#' 
#' If the argument \code{flat} is \code{TRUE}, the function takes the list of lists and configures it into a flattened table where the columns represent the battery items and the rows represent the possible answer profiles.
#' 
#' @note This function is computationally expensive.  If there are \eqn{k} response options and the researcher wants a complete branching scheme to include \eqn{n} items, \eqn{k^{n-1}} complete branching schemes will be calculated.  Setting \eqn{n} is done via the \code{lengthThreshold} slot in the \code{Cat} object.  See \strong{Examples}.
#' 
#' This function is to allow users to access the internal functions of the package. During item selection, all calculations are done in compiled \code{C++} code.
#' 
#' 
#' @seealso \code{\link{Cat-class}}, \code{\link{checkStopRules}}, \code{\link{selectItem}}
#' 
#' 
#' @examples
#' ## Loading ltm Cat object
#' data(ltm_cat)
#' 
#' ## Setting complete branches to include 3 items
#' setLengthThreshold(ltm_cat) <- 3
#' 
#' ## Object returned is list of lists
#' ltm_list <- makeTree(ltm_cat)
#' 
#' ## Object returned is table
#' ltm_table <- makeTree(ltm_cat, flat = TRUE)
#' 
#' 
#' 
#' 
#' @author Haley Acevedo, Ryden Butler, Josh W. Cutler, Matt Malis, Jacob M. Montgomery, Tom Wilkinson, Erin Rossiter, Min Hee Seo, Alex Weil 
#' 
#' @rdname makeTree
#' 
#' @export
makeTree <- function(catObj){
  UseMethod("makeTree", catObj)
}

## New version works for grm, gpcm, ltm, and tpm.
## Comments made to help revision in the future.
## You can delete comments whenever you want to publish the function.
## I will be keeping the original function and comments, so you can request one whenever you want.

makeTree <- function(catObj, flat = FALSE){
  qlist<-names(catObj@discrimination) ## qlist is a vector of questions
  if(length(unique(qlist))!=length(qlist)){ ## If names of questions are not unique, 
    qlist<-sapply(1:length(qlist),function(x)paste("Q",x,sep=""))} ## assign question numbers
  ## nresp is a vector of the number of possible responses for each question
    nresp<-sapply(1:length(qlist),function(x)length(catObj@difficulty[[x]])+2)
  ## rlist is a matrix of possible responses for every question
  if(catObj@model=="ltm"|catObj@model=="tpm"){
    rlist<-sapply(1:length(qlist),function(x){c(-1:(nresp[x]-2), "Next")})}
  else{rlist<-sapply(1:length(qlist),function(x){c(-1, 1:(nresp[x]-1), "Next", rep(NA,max(nresp)-(nresp)[x]))})}
  ## Variables defined above are always fixed and not to be modified below

  recursiveTree<-function(catObj, output, currentq){  ## To be recursively called
  ## For this call, = for this response, what is the question to be answered?
  ## Assign that question as an element, "Next", for current output as a list.
      output<-list(Next=qlist[selectItem(catObj)$next_item])
      for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
      nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
      ## i.e. if your answer to current question is 'i', how would your catObj look in next call?
      if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|catObj@lengthThreshold==sum(!is.na(nextcat@answers))){
      ## Add any condition you would like to break the recursive call.
      ## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
      ## there will be no more question to be answered in the next call.
      ## Note: '-1' does not count toward length threshold,
      ## which results in massive computation in many cases(refer to Cat.cpp).
      ## For 15 questions, imagine starting the function from
      ##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
      ## You might want to restrict total number of questions to be asked
      ## for when the responses are massive combinations of '-1's.
        output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
      ## If one of the conditions is TRUE, don't call recursiveTree,
      ## and store the next question if your response to current question is 'i'.
      }
      else{ ## If not, move on to next question with 'nextcat',
        ## with the current response, 'i', as a list of current output, which will be the new output
        ## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
        ## the question under consideration.
        output[[rlist[i,currentq]]]<-
          recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
                      currentq=selectItem(nextcat)$next_item)
        
      }
    }
    return(output) ## Upon finishing all of the recursive calls, return output.
  }
  ## Now that we have the recursive function, start the process with inputs for makeTree()
  tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
  
  ## Flat type of the function (below) is copied from the previous version,
  ## with changes in the names of variables as I coded above.
  ## Important note: flat option doesn't work unless catObj@model has binary responses.
      
  ## flatten the tree or leave it as list of lists
  if(flat == FALSE){
    out <- tree
  }else{
    flattenTree <- function(tree){
      flatTree <- unlist(tree)
      names(flatTree) <- gsub("Next", "", names(flatTree))
      flatTree <- flatTree[order(nchar(names(flatTree)))]
      
      if(catObj@model == "ltm" | catObj@model == "tpm"){
        ans_choices <- c("-", 0:(nresp[1] - 2))
      } else {
        ans_choices <- c("-", 1:(nresp[1] - 1))
      }
      
      orderedTree <- flatTree[1]
      for(i in ans_choices[1:length(ans_choices)]){
        answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
        answers <- flatTree[substring(names(flatTree), 1, 1) == i]
        orderedTree <- c(orderedTree, answers)
      }
      
      flatTree <- orderedTree
      
      response_list <- strsplit(names(flatTree), "[.]")
      output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
      colnames(output) <- c(qlist, "NextItem")
      
      for(i in 1:length(flatTree)){
        output[i,ncol(output)] <- flatTree[i]
        if(i > 1){ 
          output[i, output[1, ncol(output)]] <- response_list[[i]][1]
          if(length(response_list[[i]]) > 1){
            for(j in 1:(length(response_list[[i]])-1)){
              output[i, flatTree[which(sapply(1:length(response_list), function(f)
                identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
            }
          }
        }
      }
      output <- as.table(as.matrix(output))
      return(output)
    }
    out <- flattenTree(tree)
  }
  return(out)
}

## Examples (uncomment to run, after updating the function)
library(catSurv)
ltm_cat@lengthThreshold<-3
catSurv::makeTree(ltm_cat,flat=T)
makeTree(ltm_cat,flat=T)
## Update: code temporarily revised to reduce computation load, i.e. regardless of response,
## the total length of tree is limited to catObj@lengthThreshold in the current code.
## To undo this arbitrary limit, refer to the comments below and fix line 75
## Current code doesn't work if you don't set lengthThreshold.
##
## Notice that the process takes much longer. No matter which lengthThreshold.
## This is because '-1' responses do not count toward length threshold in Cat.cpp.
## If you edit the code to force the number of responses,
## the result from the new function is exactly same as in the original function.
## If you want to do this, add such condition as OR statement in the 'if' condition above.
## For example, add 'catObj@lengthThreshold==sum(!is.na(nextcat@answers))' to the condition.
tpm_cat@lengthThreshold<-3
grm_cat@lengthThreshold<-3
gpcm_cat@lengthThreshold<-3
makeTree(ltm_cat,flat=T)
makeTree(tpm_cat,flat=T)
makeTree(grm_cat,flat=T)
makeTree(gpcm_cat,flat=T)
makeTree(ltm_cat,flat=F)
makeTree(tpm_cat,flat=F)
makeTree(grm_cat,flat=F)
makeTree(gpcm_cat,flat=F)


## Below are comments on the previous version, for comparison and reference.

# makeTree <- function(catObj, flat = FALSE){
#   var_names <- names(catObj@discrimination) ## var_names is a vector of questions
#   resp_options <- rep(NA, length(var_names)) ## response options for each question
#   for(i in 1:length(var_names)){            ## equals possible responses +1 (consider -1 as a response)
#     resp_options[i] <- (length(catObj@difficulty[[i]]) + 2)
#   }
#   ##q: next item to be answered
#   q <- selectItem(catObj)$next_item
#   output <- list()
#   ## each item in output responds to response options
#   for (i in 1:(resp_options[q])){
#     output[[paste(i)]] <- NA
#   }
#   output[[i+1]] <- var_names[q] ## Question to be asked is added, and it is assigned the name, "Next"
#   if(catObj@model == "ltm" | catObj@model == "tpm"){ ## Other than "Next",
#     names(output) <- c(-1:(resp_options[q] - 2), "Next") ## possible reponse options are assigned
#   } else {
#     names(output) <- c(-1, 1:(resp_options[q] - 1), "Next") ## for different models.
#   }
#   
#   ## function to be called recursively
#   ## Overview of treeList function:
#   ## 1) For each response option,
#   treeList <- function(output, catObj, var_names, resp_options){
#     for(i in 1:length(output)){       ## For each possible response options +1
#       q_names <- names(output)        ## Save current question names on 'q_names'
#       
#       if(is.na(output[[i]])){     ## If this is a response, (notice that NA is assigned for
#         ##  responses, and question number is assigned for "Next". Implying that if
#         ## output[[i]] is NA, it is a response; if not, it is "Next".)
#         if(sum(is.na(catObj@answers)) == 1){ ## If this is the last question to be answered,
#           q <- var_names[q]
#           output[[q_names[i]]] <- list(Next = q)  ## we don't need responses in the output.
#         }
#         ## If this is not the last question to be answered,
#         else{
#           ## If recorded answers did not reach stop rules,
#           this_q <- which(var_names == output[["Next"]])## store next question number to this_q
#           new_cat <- storeAnswer(catObj, this_q, as.integer(names(output)[i]))## Store answer=i to new_cat
#           q <- selectItem(new_cat)$next_item ## Given the answer, what is the next question to be asked?
#           
#           if(checkStopRules(new_cat)){
#             q<-var_names[q]
#             output[[q_names[i]]] <- list(Next = q)
#           }
#           else{
#             for(j in 1:(resp_options[q] + 1)){
#               output[[q_names[i]]][[j]] <- NA
#             }
#             output[[q_names[i]]][[j]] <- var_names[q]
#             if(catObj@model == "ltm" | catObj@model == "tpm"){
#               names(output[[q_names[i]]]) <- c(-1:(resp_options[q]-2), "Next")
#             }else{
#               names(output[[q_names[i]]]) <- c(-1, 1:(resp_options[q]-1), "Next")
#             }
#             output[[q_names[i]]] <- as.list(output[[q_names[i]]])
#             
#             ## calling it recursively
#             output[[q_names[i]]] <- treeList(output = output[[q_names[i]]],
#                                              catObj = new_cat,
#                                              var_names = var_names,
#                                              resp_options = resp_options)
#           }
#         }
#       }
#     }
#     return(output)
#   }