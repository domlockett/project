## Assign that question as an element, "Next", for current output as a list.
output<-list(Next=qlist[selectItem(catObj)$next_item])
for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
## i.e. if your answer to current question is 'i', how would your catObj look in next call?
if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|catObj@lengthThreshold==sum(!is.na(nextcat@answers))){
## Add any condition you would like to break the recursive call.
## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
## there will be no more question to be answered in the next call.
## Note: '-1' does not count toward length threshold,
## which results in massive computation in many cases(refer to Cat.cpp).
## For 15 questions, imagine starting the function from
##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
## You might want to restrict total number of questions to be asked
## for when the responses are massive combinations of '-1's.
output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
## If one of the conditions is TRUE, don't call recursiveTree,
## and store the next question if your response to current question is 'i'.
}
else{ ## If not, move on to next question with 'nextcat',
## with the current response, 'i', as a list of current output, which will be the new output
## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
## the question under consideration.
output[[rlist[i,currentq]]]<-
recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
currentq=selectItem(nextcat)$next_item)
}
}
return(output) ## Upon finishing all of the recursive calls, return output.
}
## Now that we have the recursive function, start the process with inputs for makeTree()
tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
## Flat type of the function (below) is copied from the previous version,
## with changes in the names of variables as I coded above.
## Important note: flat option doesn't work unless catObj@model has binary responses.
## flatten the tree or leave it as list of lists
if(flat == FALSE){
out <- tree
}else{
flattenTree <- function(tree){
flatTree <- unlist(tree)
names(flatTree) <- gsub("Next", "", names(flatTree))
flatTree <- flatTree[order(nchar(names(flatTree)))]
if(catObj@model == "ltm" | catObj@model == "tpm"){
ans_choices <- c("-", 0:(nresp[1] - 2))
} else {
ans_choices <- c("-", 1:(nresp[1] - 1))
}
orderedTree <- flatTree[1]
for(i in ans_choices[1:length(ans_choices)]){
answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
answers <- flatTree[substring(names(flatTree), 1, 1) == i]
orderedTree <- c(orderedTree, answers)
}
flatTree <- orderedTree
response_list <- strsplit(names(flatTree), "[.]")
output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
colnames(output) <- c(qlist, "NextItem")
for(i in 1:length(flatTree)){
output[i,ncol(output)] <- flatTree[i]
if(i > 1){
output[i, output[1, ncol(output)]] <- response_list[[i]][1]
if(length(response_list[[i]]) > 1){
for(j in 1:(length(response_list[[i]])-1)){
output[i, flatTree[which(sapply(1:length(response_list), function(f)
identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
}
}
}
}
output <- as.table(as.matrix(output))
return(output)
}
out <- flattenTree(tree)
}
return(out)
}
catObj
catObj@lengthThreshold<-2
makeTree(catObj)
makeTree(catObj,flat=T)
makeTree(ltm_cat,flat=T)
makeTree(ltm_cat,flat=T)
## This is because '-1' responses do not count toward length threshold in Cat.cpp.
## If you edit the code to force the number of responses,
## the result from the new function is exactly same as in the original function.
## If you want to do this, add such condition as OR statement in the 'if' condition above.
## For example, add 'catObj@lengthThreshold==sum(!is.na(nextcat@answers))' to the condition.
ltm_cat@lengthThreshold<-2
tpm_cat@lengthThreshold<-2
grm_cat@lengthThreshold<-2
gpcm_cat@lengthThreshold<-2
makeTree(ltm_cat,flat=T)
makeTree(tpm_cat,flat=T)
makeTree(grm_cat,flat=T)
makeTree(gpcm_cat,flat=T)
makeTree(ltm_cat,flat=F)
makeTree(tpm_cat,flat=F)
makeTree(grm_cat,flat=F)
makeTree(gpcm_cat,flat=F)
makeTree(ltm_cat,flat=T)
makeTree(tpm_cat,flat=T)
makeTree(grm_cat,flat=T)
makeTree(gpcm_cat,flat=T)
makeTree(grm_cat,flat=T)
makeTree <- function(catObj, flat = FALSE){
qlist<-names(catObj@discrimination) ## qlist is a vector of questions
if(length(unique(qlist))!=length(qlist)){ ## If names of questions are not unique,
qlist<-sapply(1:length(qlist),function(x)paste("Q",x,sep=""))} ## assign question numbers
## nresp is a vector of the number of possible responses for each question
nresp<-sapply(1:length(qlist),function(x)length(catObj@difficulty[[x]])+2)
## rlist is a matrix of possible responses for every question
if(catObj@model=="ltm"|catObj@model=="tpm"){
rlist<-sapply(1:length(qlist),function(x){c(-1:(nresp[x]-2), "Next")})}
else{rlist<-sapply(1:length(qlist),function(x){c(-1, 1:(nresp[x]-1), "Next")})}
## Variables defined above are always fixed and not to be modified below
recursiveTree<-function(catObj, output, currentq){  ## To be recursively called
## For this call, = for this response, what is the question to be answered?
## Assign that question as an element, "Next", for current output as a list.
output<-list(Next=qlist[selectItem(catObj)$next_item])
for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
## i.e. if your answer to current question is 'i', how would your catObj look in next call?
if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|ltm_cat@lengthThreshold==sum(!is.na(nextcat@answers))){
## Add any condition you would like to break the recursive call.
## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
## there will be no more question to be answered in the next call.
## Note: '-1' does not count toward length threshold,
## which results in massive computation in many cases(refer to Cat.cpp).
## For 15 questions, imagine starting the function from
##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
## You might want to restrict total number of questions to be asked
## for when the responses are massive combinations of '-1's.
output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
## If one of the conditions is TRUE, don't call recursiveTree,
## and store the next question if your response to current question is 'i'.
}
else{ ## If not, move on to next question with 'nextcat',
## with the current response, 'i', as a list of current output, which will be the new output
## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
## the question under consideration.
output[[rlist[i,currentq]]]<-
recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
currentq=selectItem(nextcat)$next_item)
}
}
return(output) ## Upon finishing all of the recursive calls, return output.
}
## Now that we have the recursive function, start the process with inputs for makeTree()
tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
## Flat type of the function (below) is copied from the previous version,
## with changes in the names of variables as I coded above.
## Important note: flat option doesn't work unless catObj@model has binary responses.
## flatten the tree or leave it as list of lists
if(flat == FALSE){
out <- tree
}else{
flattenTree <- function(tree){
flatTree <- unlist(tree)
names(flatTree) <- gsub("Next", "", names(flatTree))
flatTree <- flatTree[order(nchar(names(flatTree)))]
if(catObj@model == "ltm" | catObj@model == "tpm"){
ans_choices <- c("-", 0:(nresp[1] - 2))
} else {
ans_choices <- c("-", 1:(nresp[1] - 1))
}
orderedTree <- flatTree[1]
for(i in ans_choices[1:length(ans_choices)]){
answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
answers <- flatTree[substring(names(flatTree), 1, 1) == i]
orderedTree <- c(orderedTree, answers)
}
flatTree <- orderedTree
response_list <- strsplit(names(flatTree), "[.]")
output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
colnames(output) <- c(names(catObj@difficulty), "NextItem")
for(i in 1:length(flatTree)){
output[i,ncol(output)] <- flatTree[i]
if(i > 1){
output[i, output[1, ncol(output)]] <- response_list[[i]][1]
if(length(response_list[[i]]) > 1){
for(j in 1:(length(response_list[[i]])-1)){
output[i, flatTree[which(sapply(1:length(response_list), function(f)
identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
}
}
}
}
output <- as.table(as.matrix(output))
return(output)
}
out <- flattenTree(tree)
}
return(out)
}
makeTree(grm_cat)
makeTree(grm_cat,flat=T)
makeTree(grm_cat,flat=F)
makeTree(grm_cat,flat=T)
makeTree <- function(catObj, flat = FALSE){
qlist<-names(catObj@discrimination) ## qlist is a vector of questions
if(length(unique(qlist))!=length(qlist)){ ## If names of questions are not unique,
qlist<-sapply(1:length(qlist),function(x)paste("Q",x,sep=""))} ## assign question numbers
## nresp is a vector of the number of possible responses for each question
nresp<-sapply(1:length(qlist),function(x)length(catObj@difficulty[[x]])+2)
## rlist is a matrix of possible responses for every question
if(catObj@model=="ltm"|catObj@model=="tpm"){
rlist<-sapply(1:length(qlist),function(x){c(-1:(nresp[x]-2), "Next")})}
else{rlist<-sapply(1:length(qlist),function(x){c(-1, 1:(nresp[x]-1), "Next")})}
## Variables defined above are always fixed and not to be modified below
recursiveTree<-function(catObj, output, currentq){  ## To be recursively called
## For this call, = for this response, what is the question to be answered?
## Assign that question as an element, "Next", for current output as a list.
output<-list(Next=qlist[selectItem(catObj)$next_item])
for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
## i.e. if your answer to current question is 'i', how would your catObj look in next call?
if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|ltm_cat@lengthThreshold==sum(!is.na(nextcat@answers))){
## Add any condition you would like to break the recursive call.
## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
## there will be no more question to be answered in the next call.
## Note: '-1' does not count toward length threshold,
## which results in massive computation in many cases(refer to Cat.cpp).
## For 15 questions, imagine starting the function from
##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
## You might want to restrict total number of questions to be asked
## for when the responses are massive combinations of '-1's.
output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
## If one of the conditions is TRUE, don't call recursiveTree,
## and store the next question if your response to current question is 'i'.
}
else{ ## If not, move on to next question with 'nextcat',
## with the current response, 'i', as a list of current output, which will be the new output
## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
## the question under consideration.
output[[rlist[i,currentq]]]<-
recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
currentq=selectItem(nextcat)$next_item)
}
}
return(output) ## Upon finishing all of the recursive calls, return output.
}
## Now that we have the recursive function, start the process with inputs for makeTree()
tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
## Flat type of the function (below) is copied from the previous version,
## with changes in the names of variables as I coded above.
## Important note: flat option doesn't work unless catObj@model has binary responses.
## flatten the tree or leave it as list of lists
if(flat == FALSE){
out <- tree
}else{
flattenTree <- function(tree){
flatTree <- unlist(tree)
names(flatTree) <- gsub("Next", "", names(flatTree))
flatTree <- flatTree[order(nchar(names(flatTree)))]
if(catObj@model == "ltm" | catObj@model == "tpm"){
ans_choices <- c("-", 0:(nresp[1] - 2))
} else {
ans_choices <- c("-", 1:(nresp[1] - 1))
}
orderedTree <- flatTree[1]
for(i in ans_choices[1:length(ans_choices)]){
answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
answers <- flatTree[substring(names(flatTree), 1, 1) == i]
orderedTree <- c(orderedTree, answers)
}
flatTree <- orderedTree
response_list <- strsplit(names(flatTree), "[.]")
output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
colnames(output) <- c(qlist, "NextItem")
for(i in 1:length(flatTree)){
output[i,ncol(output)] <- flatTree[i]
if(i > 1){
output[i, output[1, ncol(output)]] <- response_list[[i]][1]
if(length(response_list[[i]]) > 1){
for(j in 1:(length(response_list[[i]])-1)){
output[i, flatTree[which(sapply(1:length(response_list), function(f)
identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
}
}
}
}
output <- as.table(as.matrix(output))
return(output)
}
out <- flattenTree(tree)
}
return(out)
}
makeTree(grm_cat,flat=T)
makeTree <- function(catObj, flat = FALSE){
library(plyr)
qlist<-names(catObj@discrimination) ## qlist is a vector of questions
if(length(unique(qlist))!=length(qlist)){ ## If names of questions are not unique,
qlist<-sapply(1:length(qlist),function(x)paste("Q",x,sep=""))} ## assign question numbers
## nresp is a vector of the number of possible responses for each question
nresp<-sapply(1:length(qlist),function(x)length(catObj@difficulty[[x]])+2)
## rlist is a matrix of possible responses for every question
if(catObj@model=="ltm"|catObj@model=="tpm"){
rlist<-sapply(1:length(qlist),function(x){c(-1:(nresp[x]-2), "Next")})}
else{rlist<-sapply(1:length(qlist),function(x){c(-1, 1:(nresp[x]-1), "Next", rep(NA,max(nresp)-(nresp)[x]))})}
## Variables defined above are always fixed and not to be modified below
recursiveTree<-function(catObj, output, currentq){  ## To be recursively called
## For this call, = for this response, what is the question to be answered?
## Assign that question as an element, "Next", for current output as a list.
output<-list(Next=qlist[selectItem(catObj)$next_item])
for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
## i.e. if your answer to current question is 'i', how would your catObj look in next call?
if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|catObj@lengthThreshold==sum(!is.na(nextcat@answers))){
## Add any condition you would like to break the recursive call.
## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
## there will be no more question to be answered in the next call.
## Note: '-1' does not count toward length threshold,
## which results in massive computation in many cases(refer to Cat.cpp).
## For 15 questions, imagine starting the function from
##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
## You might want to restrict total number of questions to be asked
## for when the responses are massive combinations of '-1's.
output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
## If one of the conditions is TRUE, don't call recursiveTree,
## and store the next question if your response to current question is 'i'.
}
else{ ## If not, move on to next question with 'nextcat',
## with the current response, 'i', as a list of current output, which will be the new output
## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
## the question under consideration.
output[[rlist[i,currentq]]]<-
recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
currentq=selectItem(nextcat)$next_item)
}
}
return(output) ## Upon finishing all of the recursive calls, return output.
}
## Now that we have the recursive function, start the process with inputs for makeTree()
tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
## Flat type of the function (below) is copied from the previous version,
## with changes in the names of variables as I coded above.
## Important note: flat option doesn't work unless catObj@model has binary responses.
## flatten the tree or leave it as list of lists
if(flat == FALSE){
out <- tree
}else{
flattenTree <- function(tree){
flatTree <- unlist(tree)
names(flatTree) <- gsub("Next", "", names(flatTree))
flatTree <- flatTree[order(nchar(names(flatTree)))]
if(catObj@model == "ltm" | catObj@model == "tpm"){
ans_choices <- c("-", 0:(nresp[1] - 2))
} else {
ans_choices <- c("-", 1:(nresp[1] - 1))
}
orderedTree <- flatTree[1]
for(i in ans_choices[1:length(ans_choices)]){
answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
answers <- flatTree[substring(names(flatTree), 1, 1) == i]
orderedTree <- c(orderedTree, answers)
}
flatTree <- orderedTree
response_list <- strsplit(names(flatTree), "[.]")
output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
colnames(output) <- c(qlist, "NextItem")
for(i in 1:length(flatTree)){
output[i,ncol(output)] <- flatTree[i]
if(i > 1){
output[i, output[1, ncol(output)]] <- response_list[[i]][1]
if(length(response_list[[i]]) > 1){
for(j in 1:(length(response_list[[i]])-1)){
output[i, flatTree[which(sapply(1:length(response_list), function(f)
identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
}
}
}
}
output <- as.table(as.matrix(output))
return(output)
}
out <- flattenTree(tree)
}
return(out)
}
makeTree(gpcm_cat)
makeTree(gpcm_cat,flat=T)
## This is because '-1' responses do not count toward length threshold in Cat.cpp.
## If you edit the code to force the number of responses,
## the result from the new function is exactly same as in the original function.
## If you want to do this, add such condition as OR statement in the 'if' condition above.
## For example, add 'catObj@lengthThreshold==sum(!is.na(nextcat@answers))' to the condition.
ltm_cat@lengthThreshold<-3
tpm_cat@lengthThreshold<-3
grm_cat@lengthThreshold<-3
gpcm_cat@lengthThreshold<-3
makeTree(ltm_cat,flat=T)
library(catSurv)
makeTree <- function(catObj, flat = FALSE){
qlist<-names(catObj@discrimination) ## qlist is a vector of questions
if(length(unique(qlist))!=length(qlist)){ ## If names of questions are not unique,
qlist<-sapply(1:length(qlist),function(x)paste("Q",x,sep=""))} ## assign question numbers
## nresp is a vector of the number of possible responses for each question
nresp<-sapply(1:length(qlist),function(x)length(catObj@difficulty[[x]])+2)
## rlist is a matrix of possible responses for every question
if(catObj@model=="ltm"|catObj@model=="tpm"){
rlist<-sapply(1:length(qlist),function(x){c(-1:(nresp[x]-2), "Next")})}
else{rlist<-sapply(1:length(qlist),function(x){c(-1, 1:(nresp[x]-1), "Next", rep(NA,max(nresp)-(nresp)[x]))})}
## Variables defined above are always fixed and not to be modified below
recursiveTree<-function(catObj, output, currentq){  ## To be recursively called
## For this call, = for this response, what is the question to be answered?
## Assign that question as an element, "Next", for current output as a list.
output<-list(Next=qlist[selectItem(catObj)$next_item])
for (i in 1:nresp[[currentq]]){ ## Loop: for each possible response
nextcat<-storeAnswer(catObj,currentq,as.numeric(rlist[i,currentq])) ## Predict next call
## i.e. if your answer to current question is 'i', how would your catObj look in next call?
if(checkStopRules(nextcat)|sum(is.na(nextcat@answers))==1|catObj@lengthThreshold==sum(!is.na(nextcat@answers))){
## Add any condition you would like to break the recursive call.
## 'sum(is.na(nextcat@answers))==1' was added to end recursive call when
## there will be no more question to be answered in the next call.
## Note: '-1' does not count toward length threshold,
## which results in massive computation in many cases(refer to Cat.cpp).
## For 15 questions, imagine starting the function from
##  -1*15 and then -1*14+0, -1*14+1,... and on and on.
## You might want to restrict total number of questions to be asked
## for when the responses are massive combinations of '-1's.
output[[rlist[i,currentq]]]<-list(Next=qlist[selectItem(nextcat)$next_item])
## If one of the conditions is TRUE, don't call recursiveTree,
## and store the next question if your response to current question is 'i'.
}
else{ ## If not, move on to next question with 'nextcat',
## with the current response, 'i', as a list of current output, which will be the new output
## for the next call. For the next call, 'selectItem(nextcat)$next_item)' will be
## the question under consideration.
output[[rlist[i,currentq]]]<-
recursiveTree(catObj=nextcat, output=output[[rlist[i,currentq]]],
currentq=selectItem(nextcat)$next_item)
}
}
return(output) ## Upon finishing all of the recursive calls, return output.
}
## Now that we have the recursive function, start the process with inputs for makeTree()
tree<-recursiveTree(catObj=catObj,output=list(),currentq=selectItem(catObj)$next_item)
## Flat type of the function (below) is copied from the previous version,
## with changes in the names of variables as I coded above.
## Important note: flat option doesn't work unless catObj@model has binary responses.
## flatten the tree or leave it as list of lists
if(flat == FALSE){
out <- tree
}else{
flattenTree <- function(tree){
flatTree <- unlist(tree)
names(flatTree) <- gsub("Next", "", names(flatTree))
flatTree <- flatTree[order(nchar(names(flatTree)))]
if(catObj@model == "ltm" | catObj@model == "tpm"){
ans_choices <- c("-", 0:(nresp[1] - 2))
} else {
ans_choices <- c("-", 1:(nresp[1] - 1))
}
orderedTree <- flatTree[1]
for(i in ans_choices[1:length(ans_choices)]){
answers <- rep(NA, (length(flatTree)-1)/length(ans_choices))
answers <- flatTree[substring(names(flatTree), 1, 1) == i]
orderedTree <- c(orderedTree, answers)
}
flatTree <- orderedTree
response_list <- strsplit(names(flatTree), "[.]")
output <- matrix(data = NA, nrow = length(flatTree), ncol = length(catObj@answers) + 1)
colnames(output) <- c(qlist, "NextItem")
for(i in 1:length(flatTree)){
output[i,ncol(output)] <- flatTree[i]
if(i > 1){
output[i, output[1, ncol(output)]] <- response_list[[i]][1]
if(length(response_list[[i]]) > 1){
for(j in 1:(length(response_list[[i]])-1)){
output[i, flatTree[which(sapply(1:length(response_list), function(f)
identical(response_list[[f]], response_list[[i]][1:j])))]]  <- response_list[[i]][j+1]
}
}
}
}
output <- as.table(as.matrix(output))
return(output)
}
out <- flattenTree(tree)
}
return(out)
}
ltm_cat@lengthThreshold<-3
catSurv::makeTree(ltm_cat)
makeTree(ltm_cat)
catSurv::makeTree(ltm_cat,flat=T)
makeTree(ltm_cat,flat=T)
catSurv::makeTree(ltm_cat,flat=T)
makeTree(ltm_cat,flat=T)
## the total length of tree is limited to catObj@lengthThreshold in the current code.
## To undo this arbitrary limit, refer to the comments below and fix line 75
## Current code doesn't work if you don't set lengthThreshold.
##
## Notice that the process takes much longer. No matter which lengthThreshold.
## This is because '-1' responses do not count toward length threshold in Cat.cpp.
## If you edit the code to force the number of responses,
## the result from the new function is exactly same as in the original function.
## If you want to do this, add such condition as OR statement in the 'if' condition above.
## For example, add 'catObj@lengthThreshold==sum(!is.na(nextcat@answers))' to the condition.
tpm_cat@lengthThreshold<-3
grm_cat@lengthThreshold<-3
gpcm_cat@lengthThreshold<-3
makeTree(ltm_cat,flat=T)
makeTree(tpm_cat,flat=T)
makeTree(grm_cat,flat=T)
makeTree(gpcm_cat,flat=T)
makeTree(ltm_cat,flat=F)
makeTree(tpm_cat,flat=F)
makeTree(grm_cat,flat=F)
makeTree(gpcm_cat,flat=F)
